use core::{
    hint,
    sync::atomic::{AtomicBool, Ordering},
};

pub struct Mutex<T> {
    is_locked: AtomicBool,
    data: T,
}

impl<T> Mutex<T> {
    pub const fn new(initial_data: T) -> Self {
        Mutex {
            is_locked: AtomicBool::new(false),
            data: initial_data,
        }
    }

    pub fn lock(&'_ mut self) -> MutexGuard<'_, T> {
        //spinlock
        if self.is_locked() {
            while self.is_locked() {
                hint::spin_loop();
            }
        }

        self.is_locked.store(true, Ordering::Release);
        return MutexGuard::from_mutex(self);
    }

    pub fn unlock(&mut self, guard: MutexGuard<'_, T>) {
        //we check references to ensure the guard was generated by this lock
        if guard.mutex as *const _ != self as *const _ {
            return;
        }

        self.is_locked.store(false, Ordering::Release);
    }

    pub fn force_unlock(&self) {
        self.is_locked.store(false, Ordering::Release);
    }

    pub fn is_locked(&self) -> bool {
        self.is_locked.load(Ordering::Acquire)
    }
}

pub struct MutexGuard<'a, T> {
    mutex: &'a mut Mutex<T>,
}

impl<'a, T> MutexGuard<'a, T> {
    fn from_mutex(mutex: &'a mut Mutex<T>) -> MutexGuard<'a, T> {
        Self { mutex }
    }

    pub fn get_value(&self) -> &T {
        &self.mutex.data
    }

    pub fn set_value(&mut self, new_value: T) {
        self.mutex.data = new_value;
    }
}

impl<'a, T> Drop for MutexGuard<'a, T> {
    fn drop(&mut self) {
        self.mutex.force_unlock();
    }
}
